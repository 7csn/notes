正则：通过函数进行处理子字符串规则表达式
    1. 规则   描述所找字符串规律
    2. 数量   规则整体或局部个数
    3. 函数   正则表达式处理函数
1. 正则函数(PHP)
    说明：$p为正则，$s为目标字符串
        preg_match($p, $s)                  //是否匹配
        preg_match_all($p, $s, $m)          //匹配结果赋给$m(多维数组)
        preg_split($p, $s)                  //正则充当分隔符，返回分割后的数组
        preg_replace($p, $r, $s)            //正则替换为$r，返回替换后的字符串
        preg_replace_callback($p, $b, $s)   //类preg_replace，区别：$b是数组或函数，指定函数，接收匹配数组，返回值充当$r
        preg_replace_callback_array($a, $s) //类preg_replace_callback，$a 形式 [ $p1 => $b1, ... , $pn => $bn ]
        preg_grep($p, $a, $f=0)             //数组$a中所有匹配元素键值对组成新数组返回；$f=PREG_GREP_INVERT时键值对为非匹配的元素
        preg_quote($s, $d=null)             //转义正则特殊字符（^$(|)[-]<>{}\.+*?!=:）,$d为其他需转义的字符，通常为/
        preg_filter($p, $r, $s)             //类preg_replace，区别：不匹配时返回null
    注：
        preg_replace参数皆可为数组，$p和$r对应，从后往前替换，$s为数组时，返回替换后的数组
        preg_filter参数$s为数组时，剔除不匹配项，返回替换后的数组
2. 正则表达式构成
    分隔符 + 描述 + 分隔符[ + 修饰符]
        分隔符：
            任意非字母/数字、非反斜线、非空白字符；
            常用正斜线(/)、hash符号(#)、取反符号(~)。
        描述：
            字符串单位为字符或字符组(见量词)
            由常规字符、元字符、量词混合组成
                元字符：
                    [...]   ...集合中任一
                        ...集合：
                            ^...    不属于...集合的字符串集合
                            x-y     ASCII顺序x~y，常见a-z、A-Z、0-9
                            xy      x、y的集合
                    \w  同[a-zA-Z0-9_]
                    \W  同[^\w]
                    \d  同[0-9]
                    \D  同[^0-9]
                    \s  空白字符；包括空格\r\n\t\v\f等
                    \S  非空白字符
                    \b  单词边界
                    \B  非单词边界
                    \   将后导特殊字符（^$(|)[-]<>{}\.+*?!=:）视为普通字符
                量词：
                    +       至少1个前导字符串
                    *       0个或多个前导字符串
                    ?       0个或1个前导字符串
                    .       任意字符；不含换行
                    {x}     x个前导字符串
                    {x,y}   x~y个前导字符串
                    {x,}    至少x个前导字符串
                    $       行尾
                    ^       行首
                    |       左右任选一边
                    ()      包围字符分组，或定义反引用，可使用\n提取(n为次序，从1开始)
        修饰符：
            i   描述不区分大小写
            s   将参数看做单行
            u   把参数当做unicode编码；可匹配中文
            m   匹配首尾内容时采用多行识别匹配
            x   忽略描述中的空白
            A   强制从头开始匹配
            U   禁止贪婪匹配(跟踪到最近匹配符并结束)
3. 正则表达式补充
    1. 贪婪匹配
        贪婪量词：+、*、{x,}
        禁止贪婪：
            (...)+      =>  (...)(...)*?
            (...)*      =>  (...)*?
            (...){x,}   =>  (...){x}(...)*?
            例：
                字符：
                    /a+/    =>  /aa*?/
                    /a*/    =>  /a*?/
                    /a{3,}  =>  /a{3}a*?/
                字符组：
                    /(abc)+/    =>  /(abc)(abc)*?/
                    /(abc)*/    =>  /(abc)(abc)*?/
                    /(abc){3,}  =>  /(abc){3}(abc)*?/
        原理：
            *          <=>  {0,}
            +          <=>  {1,}
            (...){1}   <=>  (...)
            (...){n,}  <=>  (...){n}(...){0,}   <=>  (...){n}(...)*
            (...)+     <=>  (...){1,}           <=>  (...){1}(...){0,}  <=>  (...)(...)*
    2. 后向引用
        当局部字符串必须和前面某字符组一至，可用\n引用该字符组。
        例：
            判断173是否为素数
            !preg_match('/^(x{2,})\1+$/', str_repeat('x', 173));    // str_repeat重复字符串
    3. 预查
        光标不走，预判后方(回顾前方)字符串是否符合要求，预判(回顾)项不计入匹配
        1. 零宽度正预测前瞻断言 (?=...)
            例：
                I am working!
                找出ing结尾单词词根(work)：  /\b\w+(?=ing\b)/
        2. 零宽度负预测前瞻断言 (?!...)
            例：
                I am working!
                找出非ing结尾单词(I、am)：   /\b\w{1,2}\b|\b\w*(?!ing\b)\w{3}\b/
        3. 零宽度正预测回顾断言 (?<=...)
            例：
                I am unlucky!
                找出un开头的单词词根(lucky)： /(?<=\bun)\w+\b/
        4. 零宽度负预测回顾断言 (?<!...)
            例：
                I am unlucky!
                找出非un开头的单词(I、am)：   /\b\w\b|\b\w{2}(?<!un)\w*\b/
    4. 小案例
        1. 去除字符串两端空白
            preg_replace('/^\s+|\s+$/', '', $s);
        2. 匹配中文
            1. /[\x80-\xff]+/
            2. /\p{Han}+/u
            3. /[\x{4e00}-\x{9fa5}]+/u
            4. /[\u{4e00}-\u{9fa5}]+/u
	5. 字符组取名(默认索引0,1,...)
		组(后加：?<键名>。
		例：/^a(?<bKey>b+)c$/